{"version":3,"file":"async.js","sourceRoot":"","sources":["../src/async.ts"],"names":[],"mappings":"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","sourcesContent":["import { LRUCache } from 'lru-cache';\nimport { EventEmitter } from 'events';\nimport cloneDeep from 'lodash.clonedeep';\nimport { deepFreeze } from './freeze';\nimport { syncMemoizer } from './sync';\nimport {\n  INodeStyleCallBack as CB,\n  ResultBase,\n  IParamsBase0,\n  IParamsBase1,\n  IParamsBase2,\n  IParamsBase3,\n  IParamsBase4,\n  IParamsBase5,\n  IParamsBase6,\n  IParamsBasePlus,\n} from './util';\n\ntype Callback = (err?: any, ...args: any[]) => void;\n\ntype PendingLoad = {\n  queue: Callback[];\n  expiresAt: number;\n};\n\nexport interface IMemoized<T1, T2, T3, T4, T5, T6, TResult> extends ResultBase {\n  (cb: CB<TResult>): void;\n  (a1: T1, cb: CB<TResult>): void;\n  (a1: T1, a2: T2, cb: CB<TResult>): void;\n  (a1: T1, a2: T2, a3: T3, cb: CB<TResult>): void;\n  (a1: T1, a2: T2, a3: T3, a4: T4, cb: CB<TResult>): void;\n  (a1: T1, a2: T2, a3: T3, a4: T4, a5: T5, cb: CB<TResult>): void;\n  (a1: T1, a2: T2, a3: T3, a4: T4, a5: T5, a6: T6, cb: CB<TResult>): void;\n}\n\ninterface IMemoizableFunction0<TResult> {\n  (cb: CB<TResult>): void;\n}\ninterface IMemoizableFunction1<T1, TResult> {\n  (a1: T1, cb: CB<TResult>): void;\n}\ninterface IMemoizableFunction2<T1, T2, TResult> {\n  (a1: T1, a2: T2, cb: CB<TResult>): void;\n}\ninterface IMemoizableFunction3<T1, T2, T3, TResult> {\n  (a1: T1, a2: T2, a3: T3, cb: CB<TResult>): void;\n}\ninterface IMemoizableFunction4<T1, T2, T3, T4, TResult> {\n  (a1: T1, a2: T2, a3: T3, a4: T4, cb: CB<TResult>): void;\n}\ninterface IMemoizableFunction5<T1, T2, T3, T4, T5, TResult> {\n  (a1: T1, a2: T2, a3: T3, a4: T4, a5: T5, cb: CB<TResult>): void;\n}\ninterface IMemoizableFunction6<T1, T2, T3, T4, T5, T6, TResult> {\n  (a1: T1, a2: T2, a3: T3, a4: T4, a5: T5, a6: T6, cb: CB<TResult>): void;\n}\ninterface IMemoizableFunctionPlus {\n  (...rest: any[]): void;\n}\n\ntype AsyncParamsPlus = IParamsBasePlus & {\n  load: IMemoizableFunctionPlus;\n}\ntype AsyncParams0<TResult> = IParamsBase0<TResult> & {\n  load: IMemoizableFunction0<TResult>;\n}\ntype AsyncParams1<T1, TResult> = IParamsBase1<T1, TResult> & {\n  load: IMemoizableFunction1<T1, TResult>;\n}\ntype AsyncParams2<T1, T2, TResult> = IParamsBase2<T1, T2, TResult> & {\n  load: IMemoizableFunction2<T1, T2, TResult>;\n}\ntype AsyncParams3<T1, T2, T3, TResult>\n  = IParamsBase3<T1, T2, T3, TResult> & {\n    load: IMemoizableFunction3<T1, T2, T3, TResult>;\n  }\ntype AsyncParams4<T1, T2, T3, T4, TResult>\n  = IParamsBase4<T1, T2, T3, T4, TResult> & {\n    load: IMemoizableFunction4<T1, T2, T3, T4, TResult>;\n  }\ntype AsyncParams5<T1, T2, T3, T4, T5, TResult>\n  = IParamsBase5<T1, T2, T3, T4, T5, TResult> & {\n    load: IMemoizableFunction5<T1, T2, T3, T4, T5, TResult>;\n  }\ntype AsyncParams6<T1, T2, T3, T4, T5, T6, TResult>\n  = IParamsBase6<T1, T2, T3, T4, T5, T6, TResult> & {\n    /**\n     * The function that loads the resource when is not in the cache.\n     */\n    load: IMemoizableFunction6<T1, T2, T3, T4, T5, T6, TResult>;\n  }\n\nfunction asyncMemoizer<TResult>(\n  options: AsyncParams0<TResult>\n): IMemoized<unknown, unknown, unknown, unknown, unknown, unknown, TResult>;\nfunction asyncMemoizer<T1, TResult>(\n  options: AsyncParams1<T1, TResult>\n): IMemoized<T1, unknown, unknown, unknown, unknown, unknown, TResult>;\nfunction asyncMemoizer<T1, T2, TResult>(\n  options: AsyncParams2<T1, T2, TResult>\n): IMemoized<T1, T2, unknown, unknown, unknown, unknown, TResult>;\nfunction asyncMemoizer<T1, T2, T3, TResult>(\n  options: AsyncParams3<T1, T2, T3, TResult>\n): IMemoized<T1, T2, T3, unknown, unknown, unknown, TResult>;\nfunction asyncMemoizer<T1, T2, T3, T4, TResult>(\n  options: AsyncParams4<T1, T2, T3, T4, TResult>\n): IMemoized<T1, T2, T3, T4, unknown, unknown, TResult>;\nfunction asyncMemoizer<T1, T2, T3, T4, T5, TResult>(\n  options: AsyncParams5<T1, T2, T3, T4, T5, TResult>\n): IMemoized<T1, T2, T3, T4, T5, unknown, TResult>;\nfunction asyncMemoizer<T1, T2, T3, T4, T5, T6, TResult>(\n  options: AsyncParams6<T1, T2, T3, T4, T5, T6, TResult>\n): IMemoized<T1, T2, T3, T4, T5, T6, TResult>;\nfunction asyncMemoizer<T1, T2, T3, T4, T5, T6, TResult>(\n  options: AsyncParamsPlus\n): IMemoized<T1, T2, T3, T4, T5, T6, TResult> {\n  const cache = new LRUCache(options);\n  const load = options.load;\n  const hash = options.hash;\n  const bypass = options.bypass;\n  const itemTTL = options.itemTTL;\n  const freeze = options.freeze;\n  const clone = options.clone;\n  const queueTTL = options.queueTTL || 1000;\n  const loading = new Map<string, PendingLoad>();\n  const emitter = new EventEmitter();\n\n  const memoizerMethods = Object.assign({\n    del,\n    reset: () => cache.clear(),\n    keys: () => [...cache.keys()],\n    on: emitter.on.bind(emitter),\n    once: emitter.once.bind(emitter)\n  }, options);\n\n  if (options.disable) {\n    return Object.assign(load, memoizerMethods);\n  }\n\n  function del(...args: any[]) {\n    const key = hash(...args);\n    cache.delete(key);\n  }\n\n  function add(key: string, parameters: any[], result: any[]) {\n    if (freeze) {\n      result.forEach(deepFreeze);\n    }\n\n    if (itemTTL) {\n      cache.set(key, result, { ttl: itemTTL(...parameters.concat(result)) });\n    } else {\n      cache.set(key, result);\n    }\n  }\n\n  function runCallbacks(callbacks: Callback[], args: any[]) {\n    for (const callback of callbacks) {\n      // Simulate async call when returning from cache\n      // and yield between callback resolution\n      if (clone) {\n        setImmediate(callback, ...args.map(cloneDeep));\n      } else {\n        setImmediate(callback, ...args);\n      }\n    }\n  }\n\n  function emit(event: string, ...parameters: any[]) {\n    emitter.emit(event, ...parameters);\n  }\n\n  function memoizedFunction(...args: any[]) {\n    const parameters = args.slice(0, -1);\n    const callback: Callback = args.slice(-1).pop();\n    let key: string;\n\n    if (bypass && bypass(...parameters)) {\n      emit('miss', ...parameters);\n      return load(...args);\n    }\n\n    if (parameters.length === 0 && !hash) {\n      //the load function only receives callback.\n      key = '_';\n    } else {\n      key = hash(...parameters);\n    }\n\n    const fromCache = cache.get(key);\n    if (fromCache) {\n      emit('hit', ...parameters);\n      // found, invoke callback\n      return runCallbacks([callback], [null].concat(fromCache));\n    }\n\n    const pendingLoad = loading.get(key);\n    if (pendingLoad && pendingLoad.expiresAt > Date.now()) {\n      // request already in progress, queue and return\n      pendingLoad.queue.push(callback);\n      emit('queue', ...parameters);\n      return;\n    }\n\n    emit('miss', ...parameters);\n\n    const started = Date.now();\n\n    // no pending request or not resolved before expiration\n    // create a new queue and invoke load\n    const queue = [callback];\n    loading.set(key, {\n      queue,\n      expiresAt: started + queueTTL\n    });\n\n    const loadHandler = (...args: any[]) => {\n      const err = args[0];\n      if (!err) {\n        add(key, parameters, args.slice(1));\n      }\n\n      // this can potentially delete a different queue than `queue` if\n      // this callback was called after expiration.\n      // that will only cause a new call to be performed and a new queue to be\n      // created\n      loading.delete(key);\n\n      emit('loaded', Date.now() - started, ...parameters);\n      runCallbacks(queue, args);\n    };\n\n    load(...parameters, loadHandler);\n  };\n\n  return Object.assign(memoizedFunction, memoizerMethods);\n}\n\nasyncMemoizer.sync = syncMemoizer;\n\nexport { asyncMemoizer };\n"]}