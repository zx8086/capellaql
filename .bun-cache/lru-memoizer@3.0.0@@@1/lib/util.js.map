{"version":3,"file":"util.js","sourceRoot":"","sources":["../src/util.ts"],"names":[],"mappings":"","sourcesContent":["import { LRUCache } from 'lru-cache';\nexport type Listener = (...as: any[]) => void;\nexport type INodeStyleCallBack<Success> = (\n  err: Error | null,\n  result?: Success\n) => void;\n\nexport interface ResultBase {\n  /**\n   * Returns all keys in the cache.\n   */\n  keys: () => string[];\n\n  /**\n   * Clear the cache.\n   */\n  reset: () => void;\n\n  /**\n   * Delete an item given the parameters.\n   */\n  del: <T1, T2, T3, T4, T5, T6>(\n    a1?: T1,\n    a2?: T2,\n    a3?: T3,\n    a4?: T4,\n    a5?: T5,\n    a6?: T6\n  ) => void;\n  on(event: 'hit', handler: Listener): void;\n  on(event: 'miss', handler: Listener): void;\n  on(event: 'queue', handler: Listener): void;\n}\n\nexport interface IHashingFunction0 {\n  (): string;\n}\nexport interface IHashingFunction1<T1> {\n  (a1: T1): string;\n}\nexport interface IHashingFunction2<T1, T2> {\n  (a1: T1, a2: T2): string;\n}\nexport interface IHashingFunction3<T1, T2, T3> {\n  (a1: T1, a2: T2, a3: T3): string;\n}\nexport interface IHashingFunction4<T1, T2, T3, T4> {\n  (a1: T1, a2: T2, a3: T3, a4: T4): string;\n}\nexport interface IHashingFunction5<T1, T2, T3, T4, T5> {\n  (a1: T1, a2: T2, a3: T3, a4: T4, a5: T5): string;\n}\nexport interface IHashingFunction6<T1, T2, T3, T4, T5, T6> {\n  (a1: T1, a2: T2, a3: T3, a4: T4, a5: T5, a6: T6): string;\n}\nexport interface IHashingFunctionPlus<> {\n  (...rest: any[]): string;\n}\n\nexport interface IBypassFunction0 {\n  (): boolean;\n}\nexport interface IBypassFunction1<T1> {\n  (a1: T1): boolean;\n}\nexport interface IBypassFunction2<T1, T2> {\n  (a1: T1, a2: T2): boolean;\n}\nexport interface IBypassFunction3<T1, T2, T3> {\n  (a1: T1, a2: T2, a3: T3): boolean;\n}\nexport interface IBypassFunction4<T1, T2, T3, T4> {\n  (a1: T1, a2: T2, a3: T3, a4: T4): boolean;\n}\nexport interface IBypassFunction5<T1, T2, T3, T4, T5> {\n  (a1: T1, a2: T2, a3: T3, a4: T4, a5: T5): boolean;\n}\nexport interface IBypassFunction6<T1, T2, T3, T4, T5, T6> {\n  (a1: T1, a2: T2, a3: T3, a4: T4, a5: T5, a6: T6): boolean;\n}\nexport interface IBypassFunctionPlus {\n  (...rest: any[]): boolean;\n}\n\nexport interface ITTLFunction0<TResult> {\n  (res: TResult): number;\n}\nexport interface ITTLFunction1<T1, TResult> {\n  (a1: T1, res: TResult): number;\n}\nexport interface ITTLFunction2<T1, T2, TResult> {\n  (a1: T1, a2: T2, res: TResult): number;\n}\nexport interface ITTLFunction3<T1, T2, T3, TResult> {\n  (a1: T1, a2: T2, a3: T3, res: TResult): number;\n}\nexport interface ITTLFunction4<T1, T2, T3, T4, TResult> {\n  (a1: T1, a2: T2, a3: T3, a4: T4, res: TResult): number;\n}\nexport interface ITTLFunction5<T1, T2, T3, T4, T5, TResult> {\n  (a1: T1, a2: T2, a3: T3, a4: T4, a5: T5, res: TResult): number;\n}\nexport interface ITTLFunction6<T1, T2, T3, T4, T5, T6, TResult> {\n  (a1: T1, a2: T2, a3: T3, a4: T4, a5: T5, a6: T6, res: TResult): number;\n}\nexport interface ITTLFunctionPlus {\n  (...rest: any[]): number;\n}\n\nexport type IParamsBase0<TResult> = IParamsBaseCommons & {\n  hash: IHashingFunction0;\n  bypass?: IBypassFunction0;\n  itemTTL?: ITTLFunction0<TResult>;\n}\nexport type IParamsBase1<T1, TResult> = IParamsBaseCommons & {\n  hash: IHashingFunction1<T1>;\n  bypass?: IBypassFunction1<T1>;\n  itemTTL?: ITTLFunction1<T1, TResult>;\n}\nexport type IParamsBase2<T1, T2, TResult> = IParamsBaseCommons & {\n  hash: IHashingFunction2<T1, T2>;\n  bypass?: IBypassFunction2<T1, T2>;\n  itemTTL?: ITTLFunction2<T1, T2, TResult>;\n}\nexport type IParamsBase3<T1, T2, T3, TResult> = IParamsBaseCommons & {\n  hash: IHashingFunction3<T1, T2, T3>;\n  bypass?: IBypassFunction3<T1, T2, T3>;\n  itemTTL?: ITTLFunction3<T1, T2, T3, TResult>;\n}\nexport type IParamsBase4<T1, T2, T3, T4, TResult>\n  = IParamsBaseCommons & {\n    hash: IHashingFunction4<T1, T2, T3, T4>;\n    bypass?: IBypassFunction4<T1, T2, T3, T4>;\n    itemTTL?: ITTLFunction4<T1, T2, T3, T4, TResult>;\n  }\nexport type IParamsBase5<T1, T2, T3, T4, T5, TResult>\n  = IParamsBaseCommons & {\n    hash: IHashingFunction5<T1, T2, T3, T4, T5>;\n    bypass?: IBypassFunction5<T1, T2, T3, T4, T5>;\n    itemTTL?: ITTLFunction5<T1, T2, T3, T4, T5, TResult>;\n  }\nexport type IParamsBase6<T1, T2, T3, T4, T5, T6, TResult>\n  = IParamsBaseCommons & {\n    /**\n     * A function to generate the key of the cache.\n     */\n    hash: IHashingFunction6<T1, T2, T3, T4, T5, T6>;\n\n    /**\n     * Return true if the result should not be retrieved from the cache.\n     */\n    bypass?: IBypassFunction6<T1, T2, T3, T4, T5, T6>;\n\n    /**\n     * An optional function to indicate the ttl of an specific item.\n     */\n    itemTTL?: ITTLFunction6<T1, T2, T3, T4, T5, T6, TResult>;\n  }\nexport type IParamsBasePlus = IParamsBaseCommons & {\n  hash: IHashingFunctionPlus;\n  bypass?: IBypassFunctionPlus;\n  itemTTL?: ITTLFunctionPlus;\n}\ntype IParamsBaseCommons = LRUCache.Options<string, any, unknown> & {\n  /**\n   * Indicates if the resource should be freezed.\n   */\n  freeze?: boolean;\n\n  /**\n   * Indicates if the resource should be cloned before is returned.\n   */\n  clone?: boolean;\n\n  /**\n   * Disable the cache and executes the load logic directly.\n   */\n  disable?: boolean;\n\n  /**\n   * Do not queue requests if initial call is more than `queueTTL` milliseconds old.\n   * Instead, invoke `load` again and create a new queue.\n   * Defaults to 1000ms.\n   */\n  queueTTL?: number;\n}\n"]}